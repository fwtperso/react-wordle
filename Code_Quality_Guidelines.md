{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # Code_Quality_Guidelines.md\
\
## Introduction\
These guidelines define the standard of quality for all code generated for this project. The goal is not just to create code that works, but code that is also clean, readable, and easy to maintain by other developers in the future. The prompts generated by this Gem must enforce these principles.\
\
---\
\
### 1. Readability and Naming Conventions\
Code is read far more often than it is written. Clarity is paramount.\
\
* **Descriptive Naming:** Variable, function, and component names must be descriptive and unambiguous. Avoid abbreviations.\
    * **Good:** `userProfile`, `calculateTotalPrice`, `submitOrderButton`\
    * **Bad:** `uProf`, `calc`, `btn`\
* **Consistent Formatting:** Code must be consistently formatted with proper indentation and spacing. This makes the logical structure of the code immediately apparent.\
* **Single Responsibility Principle:** Functions and components should be small and focused on a single, well-defined task. A function that fetches user data should not also be responsible for rendering it.\
\
---\
\
### 2. Commenting and Documentation\
Good comments explain the "why," not the "what."\
\
* **Clarify Intent:** Use comments to explain complex algorithms, business logic, or the reasoning behind a particular implementation choice. The code itself shows what it's doing; the comment should explain why.\
* **`TODO` Tags:** Use `// TODO:` tags to mark areas where future work is needed, such as planned refactoring or features that are not yet implemented.\
* **Function/Component Headers:** For complex functions or components, a brief comment at the top explaining its purpose, parameters, and what it returns can be invaluable.\
\
---\
\
### 3. Error Handling\
Robust applications anticipate and gracefully handle errors.\
\
* **Anticipate Failures:** Assume that external services can fail, network connections can drop, and user inputs can be invalid.\
* **Implement Graceful Handling:** Use mechanisms like `try...catch` blocks to manage potential errors without crashing the application.\
* **Provide User Feedback:** When an error occurs that affects the user, provide a clear and helpful error message (e.g., "Failed to load profile. Please check your internet connection."). For silent errors, log them to the console for debugging.\
\
---\
\
### 4. Rigorous Testing and Validation\
Code is not considered complete or "done" until it has been thoroughly tested and verified. The AI must be instructed to treat testing as an integral part of the development process.\
\
* **No Code Without Tests:** Every feature must be accompanied by instructions for testing. This can be in the form of automated unit tests, integration tests, or a clear, step-by-step manual testing plan.\
* **Test Extensively Before Committing:** The AI's process must include a validation step. It should generate the code and then generate and execute tests to verify its correctness *before* presenting the final solution.\
* **Cover Edge Cases:** Testing must go beyond the "happy path." Actively consider and test for edge cases, such as empty inputs, invalid data formats, zero values, and unexpected user interactions.\
* **Verify Acceptance Criteria:** Every generated feature must be validated against its acceptance criteria.\
\
---\
\
### 5. Surgical and Incremental Changes\
Code modifications must be targeted and precise to avoid unintended side effects and to respect the integrity of the existing codebase.\
\
* **Identify the Exact Location:** Prompts must instruct the AI to first identify the specific files, components, or functions that need modification.\
* **Limit the Blast Radius:** The AI must be explicitly instructed *not* to rewrite entire files. Changes should be limited to the smallest possible block of code required to implement the new feature or fix.\
* **Provide Clear Instructions:** The output should clearly state what to add, remove, or replace in the existing code, rather than providing an entire new file. This makes code reviews and integration much simpler and safer.}